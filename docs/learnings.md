# Learnings from Development Issues

This document captures issues encountered during development and provides proactive strategies to prevent them in future AI agent coding sessions.

## Issues Encountered and Resolutions

### 1. Documentation Comment Style (clippy::empty-line-after-doc-comments)

**Issue**: Empty line between module documentation and function documentation
```rust
// INCORRECT
/// Module documentation
/// continues here

/// Function documentation
pub fn foo() {}
```

**Resolution**: Use inner doc comments (`//!`) for module-level documentation
```rust
// CORRECT
//! Module documentation
//! continues here

/// Function documentation
pub fn foo() {}
```

**Proactive Prevention**:
- Always use `//!` for module/crate-level documentation
- Use `///` only for documenting the item immediately following
- No empty lines between doc comment and documented item

### 2. Unused Imports

**Issue**: Imported `std::path::Path` but never used it
```rust
use std::path::Path;  // Never actually used
```

**Resolution**: Remove unused imports

**Proactive Prevention**:
- Only add imports when actually using them in code
- After refactoring, scan for and remove unused imports
- Run `cargo check` frequently during development to catch these early

### 3. Needless Borrows in Generic Arguments (clippy::needless-borrows-for-generic-args)

**Issue**: Unnecessary borrowing when passing arrays to functions
```rust
// INCORRECT
Args::parse_from(&["proact", "arg"]);
```

**Resolution**: Remove the borrow
```rust
// CORRECT
Args::parse_from(["proact", "arg"]);
```

**Proactive Prevention**:
- Arrays and slices often don't need explicit borrowing in generic contexts
- When passing literals to generic functions, try without `&` first
- Trust clippy's suggestions for borrowing patterns

### 4. Uninlined Format Arguments (clippy::uninlined-format-args)

**Issue**: Using positional arguments in format strings
```rust
// INCORRECT
format!("Generated by: {}", project_name)
```

**Resolution**: Use inline variable names
```rust
// CORRECT
format!("Generated by: {project_name}")
```

**Proactive Prevention**:
- Always use inline format arguments when variables are available
- This makes code more readable and less error-prone
- Applies to `format!`, `println!`, `eprintln!`, etc.

### 5. Edition Specification

**Issue**: Used incorrect edition specification

**Resolution**: Use `edition = "2024"` (the latest stable edition as of 2025)

**Proactive Prevention**:
- Always use stable Rust editions: "2015", "2018", "2021", or "2024"
- Check current stable edition before specifying
- Default to "2024" for new projects to get latest language features
- Note: Rust 2024 edition was stabilized in late 2024

## General Patterns and Best Practices

### Always Run the Checkpoint Sequence

Before considering any task complete:
1. `cargo clippy --all-targets --all-features -- -D warnings`
2. `cargo fmt`
3. `cargo test`

This catches issues early and ensures code quality.

### Clippy Configuration Recommendations

For AI agents working with Rust, always use strict clippy settings:
```bash
cargo clippy --all-targets --all-features -- -D warnings
```

This treats all warnings as errors, forcing immediate resolution.

### Import Management Strategy

1. Start with minimal imports
2. Add imports only as needed
3. After refactoring, audit imports
4. Let the compiler guide you - missing imports produce clear errors

### Documentation Comments Best Practices

1. **Module/Crate docs**: Use `//!` at the top of the file
2. **Item docs**: Use `///` immediately before the item
3. **No empty lines**: Between doc comment and documented item
4. **Complete sentences**: End with periods
5. **Examples when helpful**: Use doc tests for usage examples

### Format String Evolution

Modern Rust prefers inline format arguments:
- ❌ `format!("{} {}", foo, bar)`
- ✅ `format!("{foo} {bar}")`
- ✅ `format!("{name}: {value}")`

This applies to all formatting macros.

## Proactive AI Agent Guidelines

### Before Writing Code
1. Check Rust edition compatibility
2. Plan module structure to minimize circular dependencies
3. Consider which traits need to be imported

### While Writing Code
1. Use inline format arguments from the start
2. Apply correct doc comment style immediately
3. Only import what's immediately needed
4. Run `cargo check` frequently (every few functions)

### Before Checkpoint
1. Run `cargo clippy` with strict settings
2. Address all warnings before proceeding
3. Run `cargo fmt` to ensure consistent style
4. Run `cargo test` to verify functionality
5. Do a final import audit

### Common Clippy Warnings to Anticipate

- `needless_borrows_for_generic_args` - Don't over-borrow
- `uninlined_format_args` - Use inline format syntax
- `unused_imports` - Remove after refactoring
- `empty_line_after_doc_comments` - Proper doc comment placement
- `redundant_field_names` - Use field init shorthand

## Test Output Management

### Best Practice: Gitignored Test Directories

**Issue**: Tests were cleaning up after themselves, making it hard to debug failures
**Resolution**: Use gitignored test output directories that persist after test runs

**Implementation**:
```rust
// Setup function removes OLD artifacts, creates fresh directory
fn setup_test_dir(test_name: &str) -> PathBuf {
    let dir = get_test_dir(test_name);
    let _ = fs::remove_dir_all(&dir);  // Clean BEFORE test
    fs::create_dir_all(&dir).unwrap();
    dir
}

// Tests end with: // No cleanup - leave for inspection
```

**Benefits**:
- Test failures leave artifacts for debugging
- Can inspect generated files after test runs
- Each test run starts fresh (pre-test cleanup)
- No pollution of version control (gitignored)

**Gitignore Pattern**:
```
/test-output/
/tmp-test-*
```

## Feature Implementation: Dry-Run Mode

### Implementation Approach
When adding the `-n/--dry-run` feature, the following design decisions were made:

1. **Dry-run implies verbose**: Users running dry-run always want to see what would happen
2. **Verbose shows actual operations**: Both verbose and dry-run modes now show file operations in shell-command format
3. **Conditional execution**: Used `if !args.dry_run` guards around actual file operations
4. **Clear user feedback**: Different messages for dry-run vs actual execution

### File Operation Logging Format
- Directory creation: `mkdir -p <path>`
- File writing: `write <path> (<size> bytes)`
- Existing directory: `# Directory already exists: <path>`

This format is familiar to developers and clearly indicates what operations would be performed.

## Critical Bug: Output Directory Location

### The Issue
**Bug**: The program was writing documentation to `./docs` or the specified `-o` directory relative to the current working directory, completely ignoring the TARGET argument.

**Expected Behavior**: Documentation should be written to `<TARGET>/docs` or `<TARGET>/<output-dir>`.

**Impact**: Users would find their documentation in the wrong location, not in their target project directory.

### Root Cause
The implementation was using `args.output_dir` directly instead of joining it with the target path. This meant:
- `proact ../my-project` would create `./docs/` instead of `../my-project/docs/`
- `proact -o custom ../my-project` would create `./custom/` instead of `../my-project/custom/`

### The Fix
```rust
// BEFORE - Wrong!
let output_file = args.output_dir.join("ai_agent_instructions.md");

// AFTER - Correct!
let output_dir = if args.output_dir.is_absolute() {
    args.output_dir.clone()
} else {
    args.target.join(&args.output_dir)  // Join with target!
};
let output_file = output_dir.join("ai_agent_instructions.md");
```

### Proactive Prevention
1. **Always test with different directory structures** - Don't just test in the current directory
2. **Write integration tests first** - They catch these architectural issues
3. **Question assumptions** - "Where should output go?" should be explicitly defined
4. **Think about user expectations** - Users expect output in their project, not the tool's CWD

### Additional Feature: Learnings.md Management
While fixing this, also added:
- Automatic copying of `learnings.md` to target project
- Append mode with timestamp separator for existing learnings files
- This ensures knowledge is propagated to projects using the tool

## Markdown File Character Encoding Issues

### The Issue
**Bug**: Using special Unicode characters (smart quotes, em dashes, etc.) in Markdown files causes GitHub to fail parsing and display raw formatting codes instead of rendered content.

**Examples of problematic characters**:
- Smart quotes: "" '' (U+201C, U+201D, U+2018, U+2019)
- Em dash: — (U+2014)
- En dash: – (U+2013)
- Ellipsis: … (U+2026)
- Non-breaking spaces and other invisible Unicode

**Impact**: README.md and other documentation appears broken on GitHub, showing the underlying Markdown syntax rather than formatted content.

### Root Cause
Some text editors or copy-paste operations introduce "smart" typography characters that look correct in the editor but break GitHub's Markdown parser.

### The Fix
Always use ASCII-safe characters in Markdown files:
- Use straight quotes: " and '
- Use double hyphen for em dash: --
- Use single hyphen for en dash: -
- Use three periods for ellipsis: ...
- Avoid any non-ASCII characters unless absolutely necessary

### Proactive Prevention
1. **Always use plain text editors** for Markdown files
2. **Avoid copy-paste** from word processors or web pages
3. **Check for Unicode**: Use `file -I` command to verify encoding
4. **Test on GitHub**: Preview changes before committing
5. **Use ASCII alternatives**: Stick to basic ASCII characters for all formatting

### Detection Command
```bash
# Check for non-ASCII characters in Markdown files
grep -P "[\x80-\xFF]" *.md
```

## API Key Management Best Practices

### The Issue
**Problem**: Scattered API keys across multiple project-specific `.env` files leads to:
- Duplication of secrets
- Higher risk of accidental commits
- Maintenance overhead when rotating keys
- Confusion about which file contains which keys

**Initial Approach**: Project had `.env`, `.env.openai`, `.env.local` files with different keys.

### The Solution
**Centralized API Key Management**: Store all API keys in `~/.env` and symlink from projects.

### Implementation
```bash
# In ~/.env - single source of truth
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
LITELLM_MASTER_KEY=sk-local-test-key-123
POSTGRES_PASSWORD=localtest123

# In project directory - symlink
ln -sf ~/.env .env
```

### Benefits
1. **Security**: Keys stored outside project directories
2. **Simplicity**: One location to update all keys
3. **Portability**: Works across all projects
4. **Git Safety**: Symlinks to home directory never contain actual keys
5. **Docker Compatibility**: Docker Compose reads `.env` automatically

### Proactive Prevention
1. **Always use `~/.env`** for sensitive API keys
2. **Create symlinks** in projects that need the keys
3. **Never create project-specific key files** like `.env.openai` or `.env.providers`
4. **Add to .gitignore**: Ensure `.env` is always excluded (even though it's a symlink)
5. **Document the pattern**: Make it clear in README that keys are in `~/.env`

### Docker Compose Consideration
Docker Compose automatically reads `.env` from the project directory, making the symlink approach seamless:
```yaml
# No env_file directive needed - Docker finds .env automatically
environment:
  OPENAI_API_KEY: ${OPENAI_API_KEY:-}  # Uses value from .env symlink
```

## Continuous Improvement

Each time a new pattern of issue is discovered:
1. Document it in this file
2. Add to the proactive prevention strategies
3. Consider if it should be added to the generated AI agent documentation
4. Update templates if it's a common pattern across languages

By following these guidelines, AI agents can produce higher quality code on the first attempt, reducing the need for correction cycles and improving overall development efficiency.